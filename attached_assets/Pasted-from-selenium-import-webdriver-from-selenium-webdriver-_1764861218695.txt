from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException, ElementClickInterceptedException
import time
import sys
import math

# ================================
#   CONFIGURA√á√ÉO DO DRIVER
# ================================
def iniciar_driver():
    options = Options()
    options.add_argument("--start-maximized")
    # options.add_argument("--headless")  # ative se quiser rodar sem abrir janela
    return webdriver.Chrome(options=options)

def esperar(wait, condicao, timeout_msg="Tempo limite excedido."):
    try:
        return wait.until(condicao)
    except TimeoutException:
        raise Exception(timeout_msg)

# ================================
#   LOGIN
# ================================
def login(driver, wait, email, senha):
    driver.get("https://e-reader.arvore.com.br/login")

    campo_email = esperar(
        wait,
        EC.presence_of_element_located((By.CSS_SELECTOR, "input[type='email']")),
        "Campo de email n√£o encontrado."
    )

    campo_senha = driver.find_element(By.CSS_SELECTOR, "input[type='password']")

    campo_email.send_keys(email)
    campo_senha.send_keys(senha)

    driver.find_element(By.CSS_SELECTOR, "button[type='submit']").click()

# ================================
#   ABRIR O LIVRO
# ================================
def abrir_livro(driver, wait, slug):
    driver.get(f"https://e-reader.arvore.com.br/?slug={slug}")

    esperar(
        wait,
        EC.presence_of_element_located((By.CSS_SELECTOR, "[data-testid='reader-container']")),
        "Leitor n√£o carregou."
    )

# ================================
#   UTIL: TENTAR OBTER TOTAL DE P√ÅGINAS
# ================================
def obter_total_pages(driver):
    """
    Tenta v√°rias estrat√©gias comuns para ler o total de p√°ginas no leitor.
    Retorna int total se encontrado, caso contr√°rio None.
    """
    selectors = [
        "[data-testid='total-pages']",
        "[data-testid='pages-total']",
        ".total-pages",
        ".reader-total-pages",
        ".pagination .total",
        ".page-count .total",
        "#total-pages",
        ".total"
    ]

    for sel in selectors:
        try:
            el = driver.find_element(By.CSS_SELECTOR, sel)
            text = el.text.strip()
            # extrair n√∫mero de poss√≠vel formato "de 123" ou "123"
            digits = ''.join(ch for ch in text if ch.isdigit())
            if digits:
                return int(digits)
        except Exception:
            continue

    # tentar procurar um elemento que mostre "x / y" (ex: "12 / 300")
    try:
        candidates = driver.find_elements(By.XPATH, "//*[contains(text(),'/')]")
        for c in candidates:
            txt = c.text.strip()
            if '/' in txt:
                parts = txt.split('/')
                if len(parts) >= 2:
                    right = ''.join(ch for ch in parts[-1] if ch.isdigit())
                    if right:
                        return int(right)
    except Exception:
        pass

    return None

# ================================
#   UTIL: BARRA DE PROGRESSO NO TERMINAL
# ================================
def imprimir_barra_progresso(current, total=None, width=30, prefix=""):
    """
    Se total for conhecido, imprime barra percentual.
    Se total for None, imprime contador com spinner (indeterminado).
    """
    if total and total > 0:
        pct = current / total
        filled = int(math.floor(width * pct))
        bar = "‚ñà" * filled + "-" * (width - filled)
        sys.stdout.write(f"\r{prefix} |{bar}| {current}/{total} ({pct*100:5.1f}%)")
    else:
        # spinner
        spinner = ['|', '/', '-', '\\']
        spin = spinner[current % len(spinner)]
        sys.stdout.write(f"\r{prefix} {spin} P√°gina(s) virada(s): {current}")
    sys.stdout.flush()

# ================================
#   VIRAR P√ÅGINAS AT√â O FINAL (com barra)
# ================================
def virar_ate_o_final(driver, wait, intervalo=0.6, prefix="Lendo"):
    """
    Avan√ßa p√°gina por p√°gina at√© o fim.
    - tenta descobrir o total (obter_total_pages)
    - exibe barra de progresso no terminal
    - intervalo: tempo (s) entre tentativas para carregar a pr√≥xima p√°gina
    """
    pagina = 0
    total = obter_total_pages(driver)
    if total:
        print(f"üîé Total de p√°ginas detectado: {total}")
    else:
        print("üîé Total de p√°ginas n√£o detectado ‚Äî usando contador indeterminado.")

    # loop principal
    while True:
        try:
            botao_next = wait.until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "[data-testid='next-page-button']"))
            )
        except TimeoutException:
            # se o bot√£o n√£o aparecer - pode ser fim do livro
            print("\nüìò Nenhum bot√£o de avan√ßar encontrado ‚Üí possivelmente fim do livro.")
            break

        # tentar clicar normalmente
        try:
            botao_next.click()
        except (ElementClickInterceptedException, NoSuchElementException) as e:
            # tentar via JS
            try:
                driver.execute_script("arguments[0].click();", botao_next)
            except Exception:
                print("\n‚ùå N√£o foi poss√≠vel clicar no bot√£o (normal ou JS). Saindo.")
                break

        pagina += 1

        # atualizar total caso dinamicamente apare√ßa depois
        if total is None:
            try:
                maybe_total = obter_total_pages(driver)
                if maybe_total:
                    total = maybe_total
                    print(f"\nüîî Total de p√°ginas encontrado dinamicamente: {total}")
            except Exception:
                pass

        imprimir_barra_progresso(pagina, total, prefix=prefix)

        # espera curta para pr√≥xima p√°gina carregar (n√£o usar implicit_wait para esse delay)
        time.sleep(intervalo)

        # condi√ß√£o de seguran√ßa: se total conhecido e j√° alcan√ßado, parar
        if total and pagina >= total:
            print("\nüèÅ Chegou ao n√∫mero total de p√°ginas.")
            break

        # seguran√ßa extra: se o bot√£o existir mas ficar desabilitado ap√≥s clique, break
        try:
            # tentar reavaliar se o bot√£o ainda est√° clic√°vel; se n√£o for, finaliza
            still_clickable = botao_next.is_enabled() and botao_next.is_displayed()
            if not still_clickable and total is None:
                # aguarda um momento e testa buscar novamente (em algumas UI o mesmo bot√£o some/permanece desabilitado)
                time.sleep(0.5)
                try:
                    wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "[data-testid='next-page-button']")))
                except TimeoutException:
                    print("\nüìõ Bot√£o de avan√ßar n√£o est√° mais dispon√≠vel ‚Üí fim.")
                    break
        except Exception:
            # se n√£o for poss√≠vel checar, apenas continuar e deixar o loop decidir
            pass

    print(f"\n‚úÖ Finalizado! Total de p√°ginas viradas: {pagina}")
    return pagina, total

# ================================
#   C√ìDIGO PRINCIPAL
# ================================
def main():
    driver = iniciar_driver()
    wait = WebDriverWait(driver, 20)

    try:
        login(driver, wait, "seu_email@exemplo.com", "sua_senha_segura")

        slug = "harry-potter-e-a-pedra-filosofal"
        abrir_livro(driver, wait, slug)

        # ‚Üí Aqui usa a fun√ß√£o nova AUTOM√ÅTICA com barra de progresso
        virar_ate_o_final(driver, wait, intervalo=0.6, prefix="Lendo:")

    finally:
        pass
        # driver.quit()

if __name__ == "__main__":
    main()
